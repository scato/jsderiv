export grammar Lexical {
    SourceCharacter: .;
    InputElementDiv: WhiteSpace | LineTerminator | Comment | Token | DivPunctuator;
    InputElementRegExp: WhiteSpace | LineTerminator | Comment | Token | RegularExpressionLiteral;
    WhiteSpace: "\t" | "\v" | "\f" | " " | "\u00a0" | "\ufeff" | [\s^\t\n\r\v\f \u00a0\u2028\u2029];
    LineTerminator: "\n" | "\r" | "\u2028" | "\u2029";
    LineTerminatorSequence: "\n" | "\r" ?= ~("\n") | "\u2028" | "\u2029" | "\r" "\n";
    Comment: MultiLineComment | SingleLineComment;
    MultiLineComment: "/*" MultiLineCommentChars? "*/";
    MultiLineCommentChars: MultiLineNotAsteriskChar MultiLineCommentChars? | "*" PostAsteriskCommentChars?;
    PostAsteriskCommentChars: MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars? | "*" PostAsteriskCommentChars?;
    MultiLineNotAsteriskChar: SourceCharacter & ~("*");
    MultiLineNotForwardSlashOrAsteriskChar: SourceCharacter & ~("/" | "*");
    SingleLineComment: "//" SingleLineCommentChars?;
    SingleLineCommentChars: SingleLineCommentChar SingleLineCommentChars?;
    SingleLineCommentChar: SourceCharacter & ~(LineTerminator);
    Token: IdentifierName | Punctuator | NumericLiteral | StringLiteral;
    Identifier: IdentifierName & ~(ReservedWord);
    IdentifierName: IdentifierStart | IdentifierName IdentifierPart;
    IdentifierStart: UnicodeLetter | "$" | "_" | "\\" UnicodeEscapeSequence;
    IdentifierPart: IdentifierStart | UnicodeCombiningMark | UnicodeDigit | UnicodeConnectorPunctuation | "\u200c" | "\u200d";
    UnicodeLetter: [\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}];
    UnicodeCombiningMark: [\p{Mn}\p{Mc}];
    UnicodeDigit: [\p{Nd}];
    UnicodeConnectorPunctuation: [\p{Pc}];
    ReservedWord: Keyword | FutureReservedWord | NullLiteral | BooleanLiteral;
    Keyword: "break" | "do" | "instanceof" | "typeof" | "case" | "else" | "new" | "var" | "catch" | "finally" | "return" | "void" | "continue" | "for" | "switch" | "while" | "debugger" | "function" | "this" | "with" | "default" | "if" | "throw" | "Â " | "delete" | "in" | "try";
    FutureReservedWord: "class" | "enum" | "extends" | "super" | "const" | "export" | "import" | "implements" | "let" | "private" | "public" | "interface" | "package" | "protected" | "static" | "yield";
    Punctuator: "{" | "}" | "(" | ")" | "[" | "]" | "." | ";" | "," | "<" | ">" | "<=" | ">=" | "==" | "!=" | "===" | "!==" | "+" | "-" | "*" | "%" | "++" | "--" | "<<" | ">>" | ">>>" | "&" | "|" | "^" | "!" | "~" | "&&" | "||" | "?" | ":" | "=" | "+=" | "-=" | "*=" | "%=" | "<<=" | ">>=" | ">>>=" | "&=" | "|=" | "^=";
    DivPunctuator: "/" | "/=";
    Literal: NullLiteral | BooleanLiteral | NumericLiteral | StringLiteral | RegularExpressionLiteral;
    NullLiteral: "null";
    BooleanLiteral: "true" | "false";
    NumericLiteral: DecimalLiteral | HexIntegerLiteral;
    DecimalLiteral: DecimalIntegerLiteral "." DecimalDigits? ExponentPart? | "." DecimalDigits ExponentPart? | DecimalIntegerLiteral ExponentPart?;
    DecimalIntegerLiteral: "0" | NonZeroDigit DecimalDigits?;
    DecimalDigits: DecimalDigit | DecimalDigits DecimalDigit;
    DecimalDigit: "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
    NonZeroDigit: "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
    ExponentPart: ExponentIndicator SignedInteger;
    ExponentIndicator: "e" | "E";
    SignedInteger: DecimalDigits | "+" DecimalDigits | "-" DecimalDigits;
    HexIntegerLiteral: "0x" HexDigit | "0X" HexDigit | HexIntegerLiteral HexDigit;
    HexDigit: "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F";
    StringLiteral: "\"" DoubleStringCharacters? "\"" | "'" SingleStringCharacters? "'";
    DoubleStringCharacters: DoubleStringCharacter DoubleStringCharacters?;
    SingleStringCharacters: SingleStringCharacter SingleStringCharacters?;
    DoubleStringCharacter: SourceCharacter & ~("\"" | "\\" | LineTerminator) | "\\" EscapeSequence | LineContinuation;
    SingleStringCharacter: SourceCharacter & ~("'" | "\\" | LineTerminator) | "\\" EscapeSequence | LineContinuation;
    LineContinuation: "\\" LineTerminatorSequence;
    EscapeSequence: CharacterEscapeSequence | "0" ?= ~(DecimalDigit) | HexEscapeSequence | UnicodeEscapeSequence;
    CharacterEscapeSequence: SingleEscapeCharacter | NonEscapeCharacter;
    SingleEscapeCharacter: "'" | "\"" | "\\" | "b" | "f" | "n" | "r" | "t" | "v";
    NonEscapeCharacter: SourceCharacter & ~(EscapeCharacter | LineTerminator);
    EscapeCharacter: SingleEscapeCharacter | DecimalDigit | "x" | "u";
    HexEscapeSequence: "x" HexDigit HexDigit;
    UnicodeEscapeSequence: "u" HexDigit HexDigit HexDigit HexDigit;
    RegularExpressionLiteral: "/" RegularExpressionBody "/" RegularExpressionFlags;
    RegularExpressionBody: RegularExpressionFirstChar RegularExpressionChars;
    RegularExpressionChars: "" | RegularExpressionChars RegularExpressionChar;
    RegularExpressionFirstChar: RegularExpressionNonTerminator & ~("*" | "\\" | "/" | "[") | RegularExpressionBackslashSequence | RegularExpressionClass;
    RegularExpressionChar: RegularExpressionNonTerminator & ~("\\" | "/" | "[") | RegularExpressionBackslashSequence | RegularExpressionClass;
    RegularExpressionBackslashSequence: "\\" RegularExpressionNonTerminator;
    RegularExpressionNonTerminator: SourceCharacter & ~(LineTerminator);
    RegularExpressionClass: "[" RegularExpressionClassChars "]";
    RegularExpressionClassChars: "" | RegularExpressionClassChars RegularExpressionClassChar;
    RegularExpressionClassChar: RegularExpressionNonTerminator & ~("]" | "\\") | RegularExpressionBackslashSequence;
    RegularExpressionFlags: "" | RegularExpressionFlags IdentifierPart;
    Pattern: Disjunction;
    Disjunction: Alternative | Alternative "|" Disjunction;
    Alternative: "" | Alternative Term;
    Term: Assertion | Atom | Atom Quantifier;
    Assertion: "^" | "$" | "\\" "b" | "\\" "B" | "(" "?" "=" Disjunction ")" | "(" "?" "!" Disjunction ")";
    Quantifier: QuantifierPrefix | QuantifierPrefix "?";
    QuantifierPrefix: "*" | "+" | "?" | "{" DecimalDigits "}" | "{" DecimalDigits "," "}" | "{" DecimalDigits "," DecimalDigits "}";
    Atom: PatternCharacter | "." | "\\" AtomEscape | CharacterClass | "(" Disjunction ")" | "(" "?" ":" Disjunction ")";
    PatternCharacter: SourceCharacter & ~("^" | "$" | "\\" | "." | "*" | "+" | "?" | "(" | ")" | "[" | "]" | "{" | "}" | "|");
    AtomEscape: DecimalEscape | CharacterEscape | CharacterClassEscape;
    CharacterEscape: ControlEscape | "c" ControlLetter | HexEscapeSequence | UnicodeEscapeSequence | IdentityEscape;
    ControlEscape: "f" | "n" | "r" | "t" | "v";
    ControlLetter: "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z";
    IdentityEscape: SourceCharacter & ~(IdentifierPart) | "\u200d" | "\u200c";
    DecimalEscape: DecimalIntegerLiteral ?= ~(DecimalDigit);
    CharacterClassEscape: "d" | "D" | "s" | "S" | "w" | "W";
    CharacterClass: "[" ?= ~("^") ClassRanges "]" | "[" "^" ClassRanges "]";
    ClassRanges: "" | NonemptyClassRanges;
    NonemptyClassRanges: ClassAtom | ClassAtom NonemptyClassRangesNoDash | ClassAtom "-" ClassAtom ClassRanges;
    NonemptyClassRangesNoDash: ClassAtom | ClassAtomNoDash NonemptyClassRangesNoDash | ClassAtomNoDash "-" ClassAtom ClassRanges;
    ClassAtom: "-" | ClassAtomNoDash;
    ClassAtomNoDash: SourceCharacter & ~("\\" | "]" | "-") | "\\" ClassEscape;
    ClassEscape: DecimalEscape | "b" | CharacterEscape | CharacterClassEscape;
    JSONWhiteSpace: "\t" | "\r" | "\n" | " ";
    JSONString: "\"" JSONStringCharacters? "\"";
    JSONStringCharacters: JSONStringCharacter JSONStringCharacters?;
    JSONStringCharacter: SourceCharacter & ~("\"" | "\\" | [\u0000-\u001f]) | "\\" JSONEscapeSequence;
    JSONEscapeSequence: JSONEscapeCharacter | UnicodeEscapeSequence;
    JSONEscapeCharacter: "\"" | "/" | "\\" | "b" | "f" | "n" | "r" | "t";
    JSONNumber: "-"? DecimalIntegerLiteral JSONFraction? ExponentPart?;
    JSONFraction: "." DecimalDigits;
    JSONNullLiteral: NullLiteral;
    JSONBooleanLiteral: BooleanLiteral;
    NumericLiteral: DecimalLiteral | HexIntegerLiteral | OctalIntegerLiteral;
    OctalIntegerLiteral: "0" OctalDigit | OctalIntegerLiteral OctalDigit;
    OctalDigit: "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7";
    EscapeSequence: CharacterEscapeSequence | OctalEscapeSequence | HexEscapeSequence | UnicodeEscapeSequence;
    OctalEscapeSequence: OctalDigit ?= ~(DecimalDigit) | ZeroToThree OctalDigit ?= ~(DecimalDigit) | FourToSeven OctalDigit | ZeroToThree OctalDigit OctalDigit;
    ZeroToThree: "0" | "1" | "2" | "3";
    FourToSeven: "4" | "5" | "6" | "7";
}

export grammar Syntactic {
    PrimaryExpression: "this" | Identifier | Literal | ArrayLiteral | ObjectLiteral | "(" LT*! Expression LT*! ")";
    ArrayLiteral: "[" LT*! Elision? LT*! "]" | "[" LT*! ElementList LT*! "]" | "[" LT*! ElementList LT*! "," LT*! Elision? LT*! "]";
    ElementList: Elision? LT*! AssignmentExpression | ElementList LT*! "," LT*! Elision? LT*! AssignmentExpression;
    Elision: "," | Elision LT*! ",";
    ObjectLiteral: "{" LT*! "}" | "{" LT*! PropertyNameAndValueList LT*! "}" | "{" LT*! PropertyNameAndValueList LT*! "," LT*! "}";
    PropertyNameAndValueList: PropertyAssignment | PropertyNameAndValueList LT*! "," LT*! PropertyAssignment;
    PropertyAssignment: PropertyName LT*! ":" LT*! AssignmentExpression | "get" LT*! PropertyName LT*! "(" LT*! ")" LT*! "{" LT*! FunctionBody LT*! "}" | "set" LT*! PropertyName LT*! "(" LT*! PropertySetParameterList LT*! ")" LT*! "{" LT*! FunctionBody LT*! "}";
    PropertyName: IdentifierName | StringLiteral | NumericLiteral;
    PropertySetParameterList: Identifier;
    MemberExpression: PrimaryExpression | FunctionExpression | MemberExpression LT*! "[" LT*! Expression LT*! "]" | MemberExpression LT*! "." LT*! IdentifierName | "new" LT*! MemberExpression LT*! Arguments;
    NewExpression: MemberExpression | "new" LT*! NewExpression;
    CallExpression: MemberExpression LT*! Arguments | CallExpression LT*! Arguments | CallExpression LT*! "[" LT*! Expression LT*! "]" | CallExpression LT*! "." LT*! IdentifierName;
    Arguments: "(" LT*! ")" | "(" LT*! ArgumentList LT*! ")";
    ArgumentList: AssignmentExpression | ArgumentList LT*! "," LT*! AssignmentExpression;
    LeftHandSideExpression: NewExpression | CallExpression;
    PostfixExpression: LeftHandSideExpression | LeftHandSideExpression (LT & ~LineTerminator)*! "++" | LeftHandSideExpression (LT & ~LineTerminator)*! "--";
    UnaryExpression: PostfixExpression | "delete" LT*! UnaryExpression | "void" LT*! UnaryExpression | "typeof" LT*! UnaryExpression | "++" LT*! UnaryExpression | "--" LT*! UnaryExpression | "+" LT*! UnaryExpression | "-" LT*! UnaryExpression | "~" LT*! UnaryExpression | "!" LT*! UnaryExpression;
    MultiplicativeExpression: UnaryExpression | MultiplicativeExpression LT*! "*" LT*! UnaryExpression | MultiplicativeExpression LT*! "/" LT*! UnaryExpression | MultiplicativeExpression LT*! "%" LT*! UnaryExpression;
    AdditiveExpression: MultiplicativeExpression | AdditiveExpression LT*! "+" LT*! MultiplicativeExpression | AdditiveExpression LT*! "-" LT*! MultiplicativeExpression;
    ShiftExpression: AdditiveExpression | ShiftExpression LT*! "<<" LT*! AdditiveExpression | ShiftExpression LT*! ">>" LT*! AdditiveExpression | ShiftExpression LT*! ">>>" LT*! AdditiveExpression;
    RelationalExpression: ShiftExpression | RelationalExpression LT*! "<" LT*! ShiftExpression | RelationalExpression LT*! ">" LT*! ShiftExpression | RelationalExpression LT*! "<=" LT*! ShiftExpression | RelationalExpression LT*! ">=" LT*! ShiftExpression | RelationalExpression LT*! "instanceof" LT*! ShiftExpression | RelationalExpression LT*! "in" LT*! ShiftExpression;
    RelationalExpressionNoIn: ShiftExpression | RelationalExpressionNoIn LT*! "<" LT*! ShiftExpression | RelationalExpressionNoIn LT*! ">" LT*! ShiftExpression | RelationalExpressionNoIn LT*! "<=" LT*! ShiftExpression | RelationalExpressionNoIn LT*! ">=" LT*! ShiftExpression | RelationalExpressionNoIn LT*! "instanceof" LT*! ShiftExpression;
    EqualityExpression: RelationalExpression | EqualityExpression LT*! "==" LT*! RelationalExpression | EqualityExpression LT*! "!=" LT*! RelationalExpression | EqualityExpression LT*! "===" LT*! RelationalExpression | EqualityExpression LT*! "!==" LT*! RelationalExpression;
    EqualityExpressionNoIn: RelationalExpressionNoIn | EqualityExpressionNoIn LT*! "==" LT*! RelationalExpressionNoIn | EqualityExpressionNoIn LT*! "!=" LT*! RelationalExpressionNoIn | EqualityExpressionNoIn LT*! "===" LT*! RelationalExpressionNoIn | EqualityExpressionNoIn LT*! "!==" LT*! RelationalExpressionNoIn;
    BitwiseANDExpression: EqualityExpression | BitwiseANDExpression LT*! "&" LT*! EqualityExpression;
    BitwiseANDExpressionNoIn: EqualityExpressionNoIn | BitwiseANDExpressionNoIn LT*! "&" LT*! EqualityExpressionNoIn;
    BitwiseXORExpression: BitwiseANDExpression | BitwiseXORExpression LT*! "^" LT*! BitwiseANDExpression;
    BitwiseXORExpressionNoIn: BitwiseANDExpressionNoIn | BitwiseXORExpressionNoIn LT*! "^" LT*! BitwiseANDExpressionNoIn;
    BitwiseORExpression: BitwiseXORExpression | BitwiseORExpression LT*! "|" LT*! BitwiseXORExpression;
    BitwiseORExpressionNoIn: BitwiseXORExpressionNoIn | BitwiseORExpressionNoIn LT*! "|" LT*! BitwiseXORExpressionNoIn;
    LogicalANDExpression: BitwiseORExpression | LogicalANDExpression LT*! "&&" LT*! BitwiseORExpression;
    LogicalANDExpressionNoIn: BitwiseORExpressionNoIn | LogicalANDExpressionNoIn LT*! "&&" LT*! BitwiseORExpressionNoIn;
    LogicalORExpression: LogicalANDExpression | LogicalORExpression LT*! "||" LT*! LogicalANDExpression;
    LogicalORExpressionNoIn: LogicalANDExpressionNoIn | LogicalORExpressionNoIn LT*! "||" LT*! LogicalANDExpressionNoIn;
    ConditionalExpression: LogicalORExpression | LogicalORExpression LT*! "?" LT*! AssignmentExpression LT*! ":" LT*! AssignmentExpression;
    ConditionalExpressionNoIn: LogicalORExpressionNoIn | LogicalORExpressionNoIn LT*! "?" LT*! AssignmentExpressionNoIn LT*! ":" LT*! AssignmentExpressionNoIn;
    AssignmentExpression: ConditionalExpression | LeftHandSideExpression LT*! AssignmentOperator LT*! AssignmentExpression;
    AssignmentExpressionNoIn: ConditionalExpressionNoIn | LeftHandSideExpression LT*! AssignmentOperator LT*! AssignmentExpressionNoIn;
    AssignmentOperator: "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=";
    Expression: AssignmentExpression | Expression LT*! "," LT*! AssignmentExpression;
    ExpressionNoIn: AssignmentExpressionNoIn | ExpressionNoIn LT*! "," LT*! AssignmentExpressionNoIn;
    Statement: Block | VariableStatement | EmptyStatement | ExpressionStatement | IfStatement | IterationStatement | ContinueStatement | BreakStatement | ReturnStatement | WithStatement | LabelledStatement | SwitchStatement | ThrowStatement | TryStatement | DebuggerStatement;
    Block: "{" LT*! StatementList? LT*! "}";
    StatementList: Statement | StatementList LT*! Statement;
    VariableStatement: "var" LT*! VariableDeclarationList LT*! ";";
    VariableDeclarationList: VariableDeclaration | VariableDeclarationList LT*! "," LT*! VariableDeclaration;
    VariableDeclarationListNoIn: VariableDeclarationNoIn | VariableDeclarationListNoIn LT*! "," LT*! VariableDeclarationNoIn;
    VariableDeclaration: Identifier LT*! Initialiser?;
    VariableDeclarationNoIn: Identifier LT*! InitialiserNoIn?;
    Initialiser: "=" LT*! AssignmentExpression;
    InitialiserNoIn: "=" LT*! AssignmentExpressionNoIn;
    EmptyStatement: ";";
    ExpressionStatement: ?= ~("{" | "function") LT*! Expression LT*! ";";
    IfStatement: "if" LT*! "(" LT*! Expression LT*! ")" LT*! Statement LT*! "else" LT*! Statement | "if" LT*! "(" LT*! Expression LT*! ")" LT*! Statement;
    IterationStatement: "do" LT*! Statement LT*! "while" LT*! "(" LT*! Expression LT*! ");" | "while" LT*! "(" LT*! Expression LT*! ")" LT*! Statement | "for" LT*! "(" LT*! ExpressionNoIn? LT*! ";" LT*! Expression? LT*! ";" LT*! Expression? LT*! ")" LT*! Statement | "for" LT*! "(" LT*! "var" LT*! VariableDeclarationListNoIn LT*! ";" LT*! Expression? LT*! ";" LT*! Expression? LT*! ")" LT*! Statement | "for" LT*! "(" LT*! LeftHandSideExpression LT*! "in" LT*! Expression LT*! ")" LT*! Statement | "for" LT*! "(" LT*! "var" LT*! VariableDeclarationNoIn LT*! "in" LT*! Expression LT*! ")" LT*! Statement;
    ContinueStatement: "continue" (LT & ~LineTerminator)*! Identifier? LT*! ";";
    BreakStatement: "break" (LT & ~LineTerminator)*! Identifier? LT*! ";";
    ReturnStatement: "return" (LT & ~LineTerminator)*! Expression? LT*! ";";
    WithStatement: "with" LT*! "(" LT*! Expression LT*! ")" LT*! Statement;
    SwitchStatement: "switch" LT*! "(" LT*! Expression LT*! ")" LT*! CaseBlock;
    CaseBlock: "{" LT*! CaseClauses? LT*! "}" | "{" LT*! CaseClauses? LT*! DefaultClause LT*! CaseClauses? LT*! "}";
    CaseClauses: CaseClause | CaseClauses LT*! CaseClause;
    CaseClause: "case" LT*! Expression LT*! ":" LT*! StatementList?;
    DefaultClause: "default" LT*! ":" LT*! StatementList?;
    LabelledStatement: Identifier LT*! ":" LT*! Statement;
    ThrowStatement: "throw" (LT & ~LineTerminator)*! Expression LT*! ";";
    TryStatement: "try" LT*! Block LT*! Catch | "try" LT*! Block LT*! Finally | "try" LT*! Block LT*! Catch LT*! Finally;
    Catch: "catch" LT*! "(" LT*! Identifier LT*! ")" LT*! Block;
    Finally: "finally" LT*! Block;
    DebuggerStatement: "debugger" LT*! ";";
    FunctionDeclaration: "function" LT*! Identifier LT*! "(" LT*! FormalParameterList? LT*! ")" LT*! "{" LT*! FunctionBody LT*! "}";
    FunctionExpression: "function" LT*! Identifier? LT*! "(" LT*! FormalParameterList? LT*! ")" LT*! "{" LT*! FunctionBody LT*! "}";
    FormalParameterList: Identifier | FormalParameterList LT*! "," LT*! Identifier;
    FunctionBody: SourceElements?;
    Program: SourceElements?;
    SourceElements: SourceElement | SourceElements LT*! SourceElement;
    SourceElement: Statement | FunctionDeclaration;
    JSONText: JSONValue;
    JSONValue: JSONNullLiteral | JSONBooleanLiteral | JSONObject | JSONArray | JSONString | JSONNumber;
    JSONObject: "{" LT*! "}" | "{" LT*! JSONMemberList LT*! "}";
    JSONMember: JSONString LT*! ":" LT*! JSONValue;
    JSONMemberList: JSONMember | JSONMemberList LT*! "," LT*! JSONMember;
    JSONArray: "[" LT*! "]" | "[" LT*! JSONElementList LT*! "]";
    JSONElementList: JSONValue | JSONElementList LT*! "," LT*! JSONValue;
}

export grammar String {
    StringNumericLiteral: StrWhiteSpace? | StrWhiteSpace? StrNumericLiteral StrWhiteSpace?;
    StrWhiteSpace: StrWhiteSpaceChar StrWhiteSpace?;
    StrWhiteSpaceChar: WhiteSpace | LineTerminator;
    StrNumericLiteral: StrDecimalLiteral | HexIntegerLiteral;
    StrDecimalLiteral: StrUnsignedDecimalLiteral | "+" StrUnsignedDecimalLiteral | "-" StrUnsignedDecimalLiteral;
    StrUnsignedDecimalLiteral: "Infinity" | DecimalDigits "." DecimalDigits? ExponentPart? | "." DecimalDigits ExponentPart? | DecimalDigits ExponentPart?;
    DecimalDigits: DecimalDigit | DecimalDigits DecimalDigit;
    DecimalDigit: "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
    ExponentPart: ExponentIndicator SignedInteger;
    ExponentIndicator: "e" | "E";
    SignedInteger: DecimalDigits | "+" DecimalDigits | "-" DecimalDigits;
    HexIntegerLiteral: "0x" HexDigit | "0X" HexDigit | HexIntegerLiteral HexDigit;
    HexDigit: "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F";
    uri: uriCharacters?;
    uriCharacters: uriCharacter uriCharacters?;
    uriCharacter: uriReserved | uriUnescaped | uriEscaped;
    uriReserved: ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" | ",";
    uriUnescaped: uriAlpha | DecimalDigit | uriMark;
    uriEscaped: "%" HexDigit HexDigit;
    uriAlpha: "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z";
    uriMark: "-" | "_" | "." | "!" | "~" | "*" | "`" | "(" | ")";
}
