export constructor PrimaryExpression, ArrayLiteral, ElementList, Elision, ObjectLiteral, PropertyNameAndValueList, PropertyAssignment, PropertyName, PropertySetParameterList, MemberExpression, NewExpression, CallExpression, Arguments, ArgumentList, LeftHandSideExpression, PostfixExpression, UnaryExpression, MultiplicativeExpression, AdditiveExpression, ShiftExpression, RelationalExpression, RelationalExpressionNoIn, EqualityExpression, EqualityExpressionNoIn, BitwiseANDExpression, BitwiseANDExpressionNoIn, BitwiseXORExpression, BitwiseXORExpressionNoIn, BitwiseORExpression, BitwiseORExpressionNoIn, LogicalANDExpression, LogicalANDExpressionNoIn, LogicalORExpression, LogicalORExpressionNoIn, ConditionalExpression, ConditionalExpressionNoIn, AssignmentExpression, AssignmentExpressionNoIn, AssignmentOperator, Expression, ExpressionNoIn, Statement, Block, StatementList, VariableStatement, VariableDeclarationList, VariableDeclarationListNoIn, VariableDeclaration, VariableDeclarationNoIn, Initialiser, InitialiserNoIn, EmptyStatement, ExpressionStatement, IfStatement, IterationStatement, ContinueStatement, BreakStatement, ReturnStatement, WithStatement, SwitchStatement, CaseBlock, CaseClauses, CaseClause, DefaultClause, LabelledStatement, ThrowStatement, TryStatement, Catch, Finally, DebuggerStatement, FunctionDeclaration, FunctionExpression, FormalParameterList, FunctionBody, Program, SourceElements, SourceElement, JSONText, JSONValue, JSONObject, JSONMember, JSONMemberList, JSONArray, JSONElementList;

export grammar Lexical {
    SourceCharacter: .;
    InputElementDiv: WhiteSpace | LineTerminator | Comment | Token | DivPunctuator;
    InputElementRegExp: WhiteSpace | LineTerminator | Comment | Token | RegularExpressionLiteral;
    WhiteSpace: "\t" | "\v" | "\f" | " " | "\u00a0" | "\ufeff" | [\s^\t\n\r\v\f \u00a0\u2028\u2029];
    LineTerminator: "\n" | "\r" | "\u2028" | "\u2029";
    LineTerminatorSequence: "\n" | "\r" ?= ~("\n") | "\u2028" | "\u2029" | "\r" "\n";
    Comment: MultiLineComment | SingleLineComment;
    MultiLineComment: "/*" MultiLineCommentChars? "*/";
    MultiLineCommentChars: MultiLineNotAsteriskChar MultiLineCommentChars? | "*" PostAsteriskCommentChars?;
    PostAsteriskCommentChars: MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars? | "*" PostAsteriskCommentChars?;
    MultiLineNotAsteriskChar: SourceCharacter & ~("*");
    MultiLineNotForwardSlashOrAsteriskChar: SourceCharacter & ~("/" | "*");
    SingleLineComment: "//" SingleLineCommentChars?;
    SingleLineCommentChars: SingleLineCommentChar SingleLineCommentChars?;
    SingleLineCommentChar: SourceCharacter & ~(LineTerminator);
    Token: IdentifierName | Punctuator | NumericLiteral | StringLiteral;
    Identifier: IdentifierName & ~(ReservedWord);
    IdentifierName: IdentifierStart | IdentifierName IdentifierPart;
    IdentifierStart: UnicodeLetter | "$" | "_" | "\\" UnicodeEscapeSequence;
    IdentifierPart: IdentifierStart | UnicodeCombiningMark | UnicodeDigit | UnicodeConnectorPunctuation | "\u200c" | "\u200d";
    UnicodeLetter: [\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}];
    UnicodeCombiningMark: [\p{Mn}\p{Mc}];
    UnicodeDigit: [\p{Nd}];
    UnicodeConnectorPunctuation: [\p{Pc}];
    ReservedWord: Keyword | FutureReservedWord | NullLiteral | BooleanLiteral;
    Keyword: "break" | "do" | "instanceof" | "typeof" | "case" | "else" | "new" | "var" | "catch" | "finally" | "return" | "void" | "continue" | "for" | "switch" | "while" | "debugger" | "function" | "this" | "with" | "default" | "if" | "throw" | "Â " | "delete" | "in" | "try";
    FutureReservedWord: "class" | "enum" | "extends" | "super" | "const" | "export" | "import" | "implements" | "let" | "private" | "public" | "interface" | "package" | "protected" | "static" | "yield";
    Punctuator: "{" | "}" | "(" | ")" | "[" | "]" | "." | ";" | "," | "<" | ">" | "<=" | ">=" | "==" | "!=" | "===" | "!==" | "+" | "-" | "*" | "%" | "++" | "--" | "<<" | ">>" | ">>>" | "&" | "|" | "^" | "!" | "~" | "&&" | "||" | "?" | ":" | "=" | "+=" | "-=" | "*=" | "%=" | "<<=" | ">>=" | ">>>=" | "&=" | "|=" | "^=";
    DivPunctuator: "/" | "/=";
    Literal: NullLiteral | BooleanLiteral | NumericLiteral | StringLiteral | RegularExpressionLiteral;
    NullLiteral: "null";
    BooleanLiteral: "true" | "false";
    NumericLiteral: DecimalLiteral | HexIntegerLiteral;
    DecimalLiteral: DecimalIntegerLiteral "." DecimalDigits? ExponentPart? | "." DecimalDigits ExponentPart? | DecimalIntegerLiteral ExponentPart?;
    DecimalIntegerLiteral: "0" | NonZeroDigit DecimalDigits?;
    DecimalDigits: DecimalDigit | DecimalDigits DecimalDigit;
    DecimalDigit: "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
    NonZeroDigit: "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
    ExponentPart: ExponentIndicator SignedInteger;
    ExponentIndicator: "e" | "E";
    SignedInteger: DecimalDigits | "+" DecimalDigits | "-" DecimalDigits;
    HexIntegerLiteral: "0x" HexDigit | "0X" HexDigit | HexIntegerLiteral HexDigit;
    HexDigit: "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F";
    StringLiteral: "\"" DoubleStringCharacters? "\"" | "'" SingleStringCharacters? "'";
    DoubleStringCharacters: DoubleStringCharacter DoubleStringCharacters?;
    SingleStringCharacters: SingleStringCharacter SingleStringCharacters?;
    DoubleStringCharacter: SourceCharacter & ~("\"" | "\\" | LineTerminator) | "\\" EscapeSequence | LineContinuation;
    SingleStringCharacter: SourceCharacter & ~("'" | "\\" | LineTerminator) | "\\" EscapeSequence | LineContinuation;
    LineContinuation: "\\" LineTerminatorSequence;
    EscapeSequence: CharacterEscapeSequence | "0" ?= ~(DecimalDigit) | HexEscapeSequence | UnicodeEscapeSequence;
    CharacterEscapeSequence: SingleEscapeCharacter | NonEscapeCharacter;
    SingleEscapeCharacter: "'" | "\"" | "\\" | "b" | "f" | "n" | "r" | "t" | "v";
    NonEscapeCharacter: SourceCharacter & ~(EscapeCharacter | LineTerminator);
    EscapeCharacter: SingleEscapeCharacter | DecimalDigit | "x" | "u";
    HexEscapeSequence: "x" HexDigit HexDigit;
    UnicodeEscapeSequence: "u" HexDigit HexDigit HexDigit HexDigit;
    RegularExpressionLiteral: "/" RegularExpressionBody "/" RegularExpressionFlags;
    RegularExpressionBody: RegularExpressionFirstChar RegularExpressionChars;
    RegularExpressionChars: "" | RegularExpressionChars RegularExpressionChar;
    RegularExpressionFirstChar: RegularExpressionNonTerminator & ~("*" | "\\" | "/" | "[") | RegularExpressionBackslashSequence | RegularExpressionClass;
    RegularExpressionChar: RegularExpressionNonTerminator & ~("\\" | "/" | "[") | RegularExpressionBackslashSequence | RegularExpressionClass;
    RegularExpressionBackslashSequence: "\\" RegularExpressionNonTerminator;
    RegularExpressionNonTerminator: SourceCharacter & ~(LineTerminator);
    RegularExpressionClass: "[" RegularExpressionClassChars "]";
    RegularExpressionClassChars: "" | RegularExpressionClassChars RegularExpressionClassChar;
    RegularExpressionClassChar: RegularExpressionNonTerminator & ~("]" | "\\") | RegularExpressionBackslashSequence;
    RegularExpressionFlags: "" | RegularExpressionFlags IdentifierPart;
    Pattern: Disjunction;
    Disjunction: Alternative | Alternative "|" Disjunction;
    Alternative: "" | Alternative Term;
    Term: Assertion | Atom | Atom Quantifier;
    Assertion: "^" | "$" | "\\" "b" | "\\" "B" | "(" "?" "=" Disjunction ")" | "(" "?" "!" Disjunction ")";
    Quantifier: QuantifierPrefix | QuantifierPrefix "?";
    QuantifierPrefix: "*" | "+" | "?" | "{" DecimalDigits "}" | "{" DecimalDigits "," "}" | "{" DecimalDigits "," DecimalDigits "}";
    Atom: PatternCharacter | "." | "\\" AtomEscape | CharacterClass | "(" Disjunction ")" | "(" "?" ":" Disjunction ")";
    PatternCharacter: SourceCharacter & ~("^" | "$" | "\\" | "." | "*" | "+" | "?" | "(" | ")" | "[" | "]" | "{" | "}" | "|");
    AtomEscape: DecimalEscape | CharacterEscape | CharacterClassEscape;
    CharacterEscape: ControlEscape | "c" ControlLetter | HexEscapeSequence | UnicodeEscapeSequence | IdentityEscape;
    ControlEscape: "f" | "n" | "r" | "t" | "v";
    ControlLetter: "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z";
    IdentityEscape: SourceCharacter & ~(IdentifierPart) | "\u200d" | "\u200c";
    DecimalEscape: DecimalIntegerLiteral ?= ~(DecimalDigit);
    CharacterClassEscape: "d" | "D" | "s" | "S" | "w" | "W";
    CharacterClass: "[" ?= ~("^") ClassRanges "]" | "[" "^" ClassRanges "]";
    ClassRanges: "" | NonemptyClassRanges;
    NonemptyClassRanges: ClassAtom | ClassAtom NonemptyClassRangesNoDash | ClassAtom "-" ClassAtom ClassRanges;
    NonemptyClassRangesNoDash: ClassAtom | ClassAtomNoDash NonemptyClassRangesNoDash | ClassAtomNoDash "-" ClassAtom ClassRanges;
    ClassAtom: "-" | ClassAtomNoDash;
    ClassAtomNoDash: SourceCharacter & ~("\\" | "]" | "-") | "\\" ClassEscape;
    ClassEscape: DecimalEscape | "b" | CharacterEscape | CharacterClassEscape;
    NumericLiteral: DecimalLiteral | HexIntegerLiteral | OctalIntegerLiteral;
    OctalIntegerLiteral: "0" OctalDigit | OctalIntegerLiteral OctalDigit;
    OctalDigit: "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7";
    EscapeSequence: CharacterEscapeSequence | OctalEscapeSequence | HexEscapeSequence | UnicodeEscapeSequence;
    OctalEscapeSequence: OctalDigit ?= ~(DecimalDigit) | ZeroToThree OctalDigit ?= ~(DecimalDigit) | FourToSeven OctalDigit | ZeroToThree OctalDigit OctalDigit;
    ZeroToThree: "0" | "1" | "2" | "3";
    FourToSeven: "4" | "5" | "6" | "7";
}

export grammar Syntactic extends Lexical {
    start <LineTerminator>*! Program <LineTerminator>*!;

    PrimaryExpression: ("this" | (<Identifier> -> Text) | (<Literal> -> Text) | ArrayLiteral | ObjectLiteral | ("(" -> Text) <LineTerminator>*! Expression <LineTerminator>*! (")" -> Text)) -> PrimaryExpression;
    ArrayLiteral: (("[" -> Text) <LineTerminator>*! Elision? <LineTerminator>*! ("]" -> Text) | ("[" -> Text) <LineTerminator>*! ElementList <LineTerminator>*! ("]" -> Text) | ("[" -> Text) <LineTerminator>*! ElementList <LineTerminator>*! ("," -> Text) <LineTerminator>*! Elision? <LineTerminator>*! ("]" -> Text)) -> ArrayLiteral;
    ElementList: (Elision? <LineTerminator>*! AssignmentExpression | ElementList <LineTerminator>*! ("," -> Text) <LineTerminator>*! Elision? <LineTerminator>*! AssignmentExpression) -> ElementList;
    Elision: ("," | Elision <LineTerminator>*! ("," -> Text)) -> Elision;
    ObjectLiteral: (("{" -> Text) <LineTerminator>*! ("}" -> Text) | ("{" -> Text) <LineTerminator>*! PropertyNameAndValueList <LineTerminator>*! ("}" -> Text) | ("{" -> Text) <LineTerminator>*! PropertyNameAndValueList <LineTerminator>*! ("," -> Text) <LineTerminator>*! ("}" -> Text)) -> ObjectLiteral;
    PropertyNameAndValueList: (PropertyAssignment | PropertyNameAndValueList <LineTerminator>*! ("," -> Text) <LineTerminator>*! PropertyAssignment) -> PropertyNameAndValueList;
    PropertyAssignment: (PropertyName <LineTerminator>*! (":" -> Text) <LineTerminator>*! AssignmentExpression | ("get" -> Text) <LineTerminator>*! PropertyName <LineTerminator>*! ("(" -> Text) <LineTerminator>*! (")" -> Text) <LineTerminator>*! ("{" -> Text) <LineTerminator>*! FunctionBody <LineTerminator>*! ("}" -> Text) | ("set" -> Text) <LineTerminator>*! PropertyName <LineTerminator>*! ("(" -> Text) <LineTerminator>*! PropertySetParameterList <LineTerminator>*! (")" -> Text) <LineTerminator>*! ("{" -> Text) <LineTerminator>*! FunctionBody <LineTerminator>*! ("}" -> Text)) -> PropertyAssignment;
    PropertyName: ((<IdentifierName> -> Text) | (<StringLiteral> -> Text) | (<NumericLiteral> -> Text)) -> PropertyName;
    PropertySetParameterList: ((<Identifier> -> Text)) -> PropertySetParameterList;
    MemberExpression: (PrimaryExpression | FunctionExpression | MemberExpression <LineTerminator>*! ("[" -> Text) <LineTerminator>*! Expression <LineTerminator>*! ("]" -> Text) | MemberExpression <LineTerminator>*! ("." -> Text) <LineTerminator>*! (<IdentifierName> -> Text) | ("new" -> Text) <LineTerminator>*! MemberExpression <LineTerminator>*! Arguments) -> MemberExpression;
    NewExpression: (MemberExpression | ("new" -> Text) <LineTerminator>*! NewExpression) -> NewExpression;
    CallExpression: (MemberExpression <LineTerminator>*! Arguments | CallExpression <LineTerminator>*! Arguments | CallExpression <LineTerminator>*! ("[" -> Text) <LineTerminator>*! Expression <LineTerminator>*! ("]" -> Text) | CallExpression <LineTerminator>*! ("." -> Text) <LineTerminator>*! (<IdentifierName> -> Text)) -> CallExpression;
    Arguments: (("(" -> Text) <LineTerminator>*! (")" -> Text) | ("(" -> Text) <LineTerminator>*! ArgumentList <LineTerminator>*! (")" -> Text)) -> Arguments;
    ArgumentList: (AssignmentExpression | ArgumentList <LineTerminator>*! ("," -> Text) <LineTerminator>*! AssignmentExpression) -> ArgumentList;
    LeftHandSideExpression: (NewExpression | CallExpression) -> LeftHandSideExpression;
    PostfixExpression: (LeftHandSideExpression | LeftHandSideExpression ("++" -> Text) | LeftHandSideExpression ("--" -> Text)) -> PostfixExpression;
    UnaryExpression: (PostfixExpression | ("delete" -> Text) <LineTerminator>*! UnaryExpression | ("void" -> Text) <LineTerminator>*! UnaryExpression | ("typeof" -> Text) <LineTerminator>*! UnaryExpression | ("++" -> Text) <LineTerminator>*! UnaryExpression | ("--" -> Text) <LineTerminator>*! UnaryExpression | ("+" -> Text) <LineTerminator>*! UnaryExpression | ("-" -> Text) <LineTerminator>*! UnaryExpression | ("~" -> Text) <LineTerminator>*! UnaryExpression | ("!" -> Text) <LineTerminator>*! UnaryExpression) -> UnaryExpression;
    MultiplicativeExpression: (UnaryExpression | MultiplicativeExpression <LineTerminator>*! ("*" -> Text) <LineTerminator>*! UnaryExpression | MultiplicativeExpression <LineTerminator>*! ("/" -> Text) <LineTerminator>*! UnaryExpression | MultiplicativeExpression <LineTerminator>*! ("%" -> Text) <LineTerminator>*! UnaryExpression) -> MultiplicativeExpression;
    AdditiveExpression: (MultiplicativeExpression | AdditiveExpression <LineTerminator>*! ("+" -> Text) <LineTerminator>*! MultiplicativeExpression | AdditiveExpression <LineTerminator>*! ("-" -> Text) <LineTerminator>*! MultiplicativeExpression) -> AdditiveExpression;
    ShiftExpression: (AdditiveExpression | ShiftExpression <LineTerminator>*! ("<<" -> Text) <LineTerminator>*! AdditiveExpression | ShiftExpression <LineTerminator>*! (">>" -> Text) <LineTerminator>*! AdditiveExpression | ShiftExpression <LineTerminator>*! (">>>" -> Text) <LineTerminator>*! AdditiveExpression) -> ShiftExpression;
    RelationalExpression: (ShiftExpression | RelationalExpression <LineTerminator>*! ("<" -> Text) <LineTerminator>*! ShiftExpression | RelationalExpression <LineTerminator>*! (">" -> Text) <LineTerminator>*! ShiftExpression | RelationalExpression <LineTerminator>*! ("<=" -> Text) <LineTerminator>*! ShiftExpression | RelationalExpression <LineTerminator>*! (">=" -> Text) <LineTerminator>*! ShiftExpression | RelationalExpression <LineTerminator>*! ("instanceof" -> Text) <LineTerminator>*! ShiftExpression | RelationalExpression <LineTerminator>*! ("in" -> Text) <LineTerminator>*! ShiftExpression) -> RelationalExpression;
    RelationalExpressionNoIn: (ShiftExpression | RelationalExpressionNoIn <LineTerminator>*! ("<" -> Text) <LineTerminator>*! ShiftExpression | RelationalExpressionNoIn <LineTerminator>*! (">" -> Text) <LineTerminator>*! ShiftExpression | RelationalExpressionNoIn <LineTerminator>*! ("<=" -> Text) <LineTerminator>*! ShiftExpression | RelationalExpressionNoIn <LineTerminator>*! (">=" -> Text) <LineTerminator>*! ShiftExpression | RelationalExpressionNoIn <LineTerminator>*! ("instanceof" -> Text) <LineTerminator>*! ShiftExpression) -> RelationalExpressionNoIn;
    EqualityExpression: (RelationalExpression | EqualityExpression <LineTerminator>*! ("==" -> Text) <LineTerminator>*! RelationalExpression | EqualityExpression <LineTerminator>*! ("!=" -> Text) <LineTerminator>*! RelationalExpression | EqualityExpression <LineTerminator>*! ("===" -> Text) <LineTerminator>*! RelationalExpression | EqualityExpression <LineTerminator>*! ("!==" -> Text) <LineTerminator>*! RelationalExpression) -> EqualityExpression;
    EqualityExpressionNoIn: (RelationalExpressionNoIn | EqualityExpressionNoIn <LineTerminator>*! ("==" -> Text) <LineTerminator>*! RelationalExpressionNoIn | EqualityExpressionNoIn <LineTerminator>*! ("!=" -> Text) <LineTerminator>*! RelationalExpressionNoIn | EqualityExpressionNoIn <LineTerminator>*! ("===" -> Text) <LineTerminator>*! RelationalExpressionNoIn | EqualityExpressionNoIn <LineTerminator>*! ("!==" -> Text) <LineTerminator>*! RelationalExpressionNoIn) -> EqualityExpressionNoIn;
    BitwiseANDExpression: (EqualityExpression | BitwiseANDExpression <LineTerminator>*! ("&" -> Text) <LineTerminator>*! EqualityExpression) -> BitwiseANDExpression;
    BitwiseANDExpressionNoIn: (EqualityExpressionNoIn | BitwiseANDExpressionNoIn <LineTerminator>*! ("&" -> Text) <LineTerminator>*! EqualityExpressionNoIn) -> BitwiseANDExpressionNoIn;
    BitwiseXORExpression: (BitwiseANDExpression | BitwiseXORExpression <LineTerminator>*! ("^" -> Text) <LineTerminator>*! BitwiseANDExpression) -> BitwiseXORExpression;
    BitwiseXORExpressionNoIn: (BitwiseANDExpressionNoIn | BitwiseXORExpressionNoIn <LineTerminator>*! ("^" -> Text) <LineTerminator>*! BitwiseANDExpressionNoIn) -> BitwiseXORExpressionNoIn;
    BitwiseORExpression: (BitwiseXORExpression | BitwiseORExpression <LineTerminator>*! ("|" -> Text) <LineTerminator>*! BitwiseXORExpression) -> BitwiseORExpression;
    BitwiseORExpressionNoIn: (BitwiseXORExpressionNoIn | BitwiseORExpressionNoIn <LineTerminator>*! ("|" -> Text) <LineTerminator>*! BitwiseXORExpressionNoIn) -> BitwiseORExpressionNoIn;
    LogicalANDExpression: (BitwiseORExpression | LogicalANDExpression <LineTerminator>*! ("&&" -> Text) <LineTerminator>*! BitwiseORExpression) -> LogicalANDExpression;
    LogicalANDExpressionNoIn: (BitwiseORExpressionNoIn | LogicalANDExpressionNoIn <LineTerminator>*! ("&&" -> Text) <LineTerminator>*! BitwiseORExpressionNoIn) -> LogicalANDExpressionNoIn;
    LogicalORExpression: (LogicalANDExpression | LogicalORExpression <LineTerminator>*! ("||" -> Text) <LineTerminator>*! LogicalANDExpression) -> LogicalORExpression;
    LogicalORExpressionNoIn: (LogicalANDExpressionNoIn | LogicalORExpressionNoIn <LineTerminator>*! ("||" -> Text) <LineTerminator>*! LogicalANDExpressionNoIn) -> LogicalORExpressionNoIn;
    ConditionalExpression: (LogicalORExpression | LogicalORExpression <LineTerminator>*! ("?" -> Text) <LineTerminator>*! AssignmentExpression <LineTerminator>*! (":" -> Text) <LineTerminator>*! AssignmentExpression) -> ConditionalExpression;
    ConditionalExpressionNoIn: (LogicalORExpressionNoIn | LogicalORExpressionNoIn <LineTerminator>*! ("?" -> Text) <LineTerminator>*! AssignmentExpressionNoIn <LineTerminator>*! (":" -> Text) <LineTerminator>*! AssignmentExpressionNoIn) -> ConditionalExpressionNoIn;
    AssignmentExpression: (ConditionalExpression | LeftHandSideExpression <LineTerminator>*! AssignmentOperator <LineTerminator>*! AssignmentExpression) -> AssignmentExpression;
    AssignmentExpressionNoIn: (ConditionalExpressionNoIn | LeftHandSideExpression <LineTerminator>*! AssignmentOperator <LineTerminator>*! AssignmentExpressionNoIn) -> AssignmentExpressionNoIn;
    AssignmentOperator: ("=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=") -> AssignmentOperator;
    Expression: (AssignmentExpression | Expression <LineTerminator>*! ("," -> Text) <LineTerminator>*! AssignmentExpression) -> Expression;
    ExpressionNoIn: (AssignmentExpressionNoIn | ExpressionNoIn <LineTerminator>*! ("," -> Text) <LineTerminator>*! AssignmentExpressionNoIn) -> ExpressionNoIn;
    Statement: (Block | VariableStatement | EmptyStatement | ExpressionStatement | IfStatement | IterationStatement | ContinueStatement | BreakStatement | ReturnStatement | WithStatement | LabelledStatement | SwitchStatement | ThrowStatement | TryStatement | DebuggerStatement) -> Statement;
    Block: (("{" -> Text) <LineTerminator>*! StatementList? <LineTerminator>*! ("}" -> Text)) -> Block;
    StatementList: (Statement | StatementList <LineTerminator>*! Statement) -> StatementList;
    VariableStatement: (("var" -> Text) <LineTerminator>*! VariableDeclarationList <LineTerminator>*! (";" -> Text)) -> VariableStatement;
    VariableDeclarationList: (VariableDeclaration | VariableDeclarationList <LineTerminator>*! ("," -> Text) <LineTerminator>*! VariableDeclaration) -> VariableDeclarationList;
    VariableDeclarationListNoIn: (VariableDeclarationNoIn | VariableDeclarationListNoIn <LineTerminator>*! ("," -> Text) <LineTerminator>*! VariableDeclarationNoIn) -> VariableDeclarationListNoIn;
    VariableDeclaration: ((<Identifier> -> Text) <LineTerminator>*! Initialiser?) -> VariableDeclaration;
    VariableDeclarationNoIn: ((<Identifier> -> Text) <LineTerminator>*! InitialiserNoIn?) -> VariableDeclarationNoIn;
    Initialiser: (("=" -> Text) <LineTerminator>*! AssignmentExpression) -> Initialiser;
    InitialiserNoIn: (("=" -> Text) <LineTerminator>*! AssignmentExpressionNoIn) -> InitialiserNoIn;
    EmptyStatement: (";") -> EmptyStatement;
    ExpressionStatement: (?= ~("{" | "function") <LineTerminator>*! Expression <LineTerminator>*! (";" -> Text)) -> ExpressionStatement;
    IfStatement: (("if" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! Expression <LineTerminator>*! (")" -> Text) <LineTerminator>*! Statement <LineTerminator>*! ("else" -> Text) <LineTerminator>*! Statement | ("if" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! Expression <LineTerminator>*! (")" -> Text) <LineTerminator>*! Statement) -> IfStatement;
    IterationStatement: (("do" -> Text) <LineTerminator>*! Statement <LineTerminator>*! ("while" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! Expression <LineTerminator>*! (");" -> Text) | ("while" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! Expression <LineTerminator>*! (")" -> Text) <LineTerminator>*! Statement | ("for" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! ExpressionNoIn? <LineTerminator>*! (";" -> Text) <LineTerminator>*! Expression? <LineTerminator>*! (";" -> Text) <LineTerminator>*! Expression? <LineTerminator>*! (")" -> Text) <LineTerminator>*! Statement | ("for" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! ("var" -> Text) <LineTerminator>*! VariableDeclarationListNoIn <LineTerminator>*! (";" -> Text) <LineTerminator>*! Expression? <LineTerminator>*! (";" -> Text) <LineTerminator>*! Expression? <LineTerminator>*! (")" -> Text) <LineTerminator>*! Statement | ("for" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! LeftHandSideExpression <LineTerminator>*! ("in" -> Text) <LineTerminator>*! Expression <LineTerminator>*! (")" -> Text) <LineTerminator>*! Statement | ("for" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! ("var" -> Text) <LineTerminator>*! VariableDeclarationNoIn <LineTerminator>*! ("in" -> Text) <LineTerminator>*! Expression <LineTerminator>*! (")" -> Text) <LineTerminator>*! Statement) -> IterationStatement;
    ContinueStatement: (("continue" -> Text) (<Identifier> -> Text)? <LineTerminator>*! (";" -> Text)) -> ContinueStatement;
    BreakStatement: (("break" -> Text) (<Identifier> -> Text)? <LineTerminator>*! (";" -> Text)) -> BreakStatement;
    ReturnStatement: (("return" -> Text) Expression? <LineTerminator>*! (";" -> Text)) -> ReturnStatement;
    WithStatement: (("with" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! Expression <LineTerminator>*! (")" -> Text) <LineTerminator>*! Statement) -> WithStatement;
    SwitchStatement: (("switch" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! Expression <LineTerminator>*! (")" -> Text) <LineTerminator>*! CaseBlock) -> SwitchStatement;
    CaseBlock: (("{" -> Text) <LineTerminator>*! CaseClauses? <LineTerminator>*! ("}" -> Text) | ("{" -> Text) <LineTerminator>*! CaseClauses? <LineTerminator>*! DefaultClause <LineTerminator>*! CaseClauses? <LineTerminator>*! ("}" -> Text)) -> CaseBlock;
    CaseClauses: (CaseClause | CaseClauses <LineTerminator>*! CaseClause) -> CaseClauses;
    CaseClause: (("case" -> Text) <LineTerminator>*! Expression <LineTerminator>*! (":" -> Text) <LineTerminator>*! StatementList?) -> CaseClause;
    DefaultClause: (("default" -> Text) <LineTerminator>*! (":" -> Text) <LineTerminator>*! StatementList?) -> DefaultClause;
    LabelledStatement: ((<Identifier> -> Text) <LineTerminator>*! (":" -> Text) <LineTerminator>*! Statement) -> LabelledStatement;
    ThrowStatement: (("throw" -> Text) Expression <LineTerminator>*! (";" -> Text)) -> ThrowStatement;
    TryStatement: (("try" -> Text) <LineTerminator>*! Block <LineTerminator>*! Catch | ("try" -> Text) <LineTerminator>*! Block <LineTerminator>*! Finally | ("try" -> Text) <LineTerminator>*! Block <LineTerminator>*! Catch <LineTerminator>*! Finally) -> TryStatement;
    Catch: (("catch" -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! (<Identifier> -> Text) <LineTerminator>*! (")" -> Text) <LineTerminator>*! Block) -> Catch;
    Finally: (("finally" -> Text) <LineTerminator>*! Block) -> Finally;
    DebuggerStatement: (("debugger" -> Text) <LineTerminator>*! (";" -> Text)) -> DebuggerStatement;
    FunctionDeclaration: (("function" -> Text) <LineTerminator>*! (<Identifier> -> Text) <LineTerminator>*! ("(" -> Text) <LineTerminator>*! FormalParameterList? <LineTerminator>*! (")" -> Text) <LineTerminator>*! ("{" -> Text) <LineTerminator>*! FunctionBody <LineTerminator>*! ("}" -> Text)) -> FunctionDeclaration;
    FunctionExpression: (("function" -> Text) <LineTerminator>*! (<Identifier> -> Text)? <LineTerminator>*! ("(" -> Text) <LineTerminator>*! FormalParameterList? <LineTerminator>*! (")" -> Text) <LineTerminator>*! ("{" -> Text) <LineTerminator>*! FunctionBody <LineTerminator>*! ("}" -> Text)) -> FunctionExpression;
    FormalParameterList: ((<Identifier> -> Text) | FormalParameterList <LineTerminator>*! ("," -> Text) <LineTerminator>*! (<Identifier> -> Text)) -> FormalParameterList;
    FunctionBody: (SourceElements?) -> FunctionBody;
    Program: (SourceElements?) -> Program;
    SourceElements: (SourceElement | SourceElements <LineTerminator>*! SourceElement) -> SourceElements;
    SourceElement: (Statement | FunctionDeclaration) -> SourceElement;
}
